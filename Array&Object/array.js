// 배열에 가장 중요한점은 정렬이 되어있다는것
// 데이터가 정렬되어 있는 기준이 있다.
// 한뭉치로 있는 객체와 다르다, 연산하는 시간이 더 걸릴수도 있다.

let names = ["Michael", "Melissa", "Andrea"];
let values = [true, {}, [], 2, "awesome"];

// 엘리먼트마다 붙어있는 인덱스가 있음

//배열특징
// 1. 정렬된 데이터를 위해서 사용
// 정렬되어있는것이 필요할때 배열을 사용할 수 있지만, 성능을 희생해야 할 수 있음
// 특히 입력과 제거일때

// Insertion - It depends,,
// Removal - It depends,,,,
// Searching - O(n)
// Access - O(1)

// 접근은 상수시간인 이유?
// 엘리먼트마다 바로갈 수있는 지름길이 있다. 숫자가있고 인덱스가있고 배열안에 존재하는 인덱스라며 그게 조건이다.
// 실제로 있는 인덱스로 바로 점프!

//어디에 입력하는지에 따라 달려있다.

//엘리먼트마다 붙어있는 인덱스가 있는데 , 만약 엘리먼트를 끝에다가 추가하면 O(1) 상수시간이된다. 객체에 추가하는 것과같이 어려운 작업이아니다.
// 문제가 되는것은 배열앞에 추가할때임 . 앞에 추가하게되면 인덱스가 엉망이됨 -> 배열에 있는 엘리먼트마다 인덱스를 다시 새로 배정해야된다.
// O(n) 시간이 된다. 물론 연산이 엘리먼트마다 하나씩 인것은 아니니, 1n, 2n , 5n... 등 될수 있음
// 앞에서 제거하는것도 같은 문제이다. 앞에서 제거를 하게되면, 새롭게 또 인덱스를 배정--> O(N)
// 무조건 피하라는건 아니고 끝에서 추가, 삭제 하는것 만큼효율적이지 않다는것
